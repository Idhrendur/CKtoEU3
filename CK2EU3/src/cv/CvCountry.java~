package cv;

import static utils.Check.checkFatal;

import java.util.ArrayList;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;

import rules.CountryCvRules;
import rules.CultureCvRules;
import rules.TagCvRules;
import rules.MergeRules;
import rules.CharacterCvRules;

import ck.*;
import eu3.EU3Country;

import utils.*;

/**
 * Class translating actual CK countries into a set of countries for EU3
 * 
 * @author yprelot
 */
public class CvCountry implements Comparable<CvCountry> {

	static public String[] __rotw_tags = { "ADA", "ADE", "AHM", "ANN", "ARK", "ASH", "ASS", "ATJ", "AYU", "AZT", "BAH", "BAL", "BAN", "BAS", "BEI", "BEN", "BHO", "BHU", "BIJ", "BLI", "BND", "BNG", "BRR", "BRZ", "CAM", "CAN", "CHA", "CHE", "CHG", "CHK", "CHL", "CHM", "COL", "CRE", "DAI", "DLH", "DNZ", "DUL", "DUR", "ETH", "ETR", "FRN", "GAK", "GBR", "GDW", "GOC", "GUJ", "HAT", "HAU", "HED", "HUR", "HYD", "INC", "IRO", "IRQ", "ITA", "JAP", "KBO", "KHA", "KHD", "KHI", "KHM", "KHO", "KOK", "KON", "KOR", "KRA", "KRK", "KSH", "KTH", "KZH", "LAP", "LIV", "LNA", "LOA", "LOU", "LUA", "LXA", "MAD", "MAL", "MAR", "MAY", "MCH", "MEX", "MKS", "MLB", "MLC", "MLD", "MLW", "MNG", "MTR", "MUG", "MYS", "NAJ", "NAP", "NED", "NIZ", "NOG", "NPL", "ODH", "OIR", "OMA", "ORI", "OYO", "PAP", "PAT", "PEG", "PER", "PEU", "PRG", "PRO", "PUN", "QIN", "QUE", "RAJ", "RFR", "RYU", "SHA", "SHR", "SHY", "SIB", "SND", "SOF", "SOK", "SON", "SPA", "SPI", "SST", "SUL", "SYR", "TAU", "TIB", "TIM", "TOK", "TRV", "USA", "VIE", "VIJ", "VNZ", "WES", "WUU", "XIA", "ZAN", "ZAP", "ZIM" };
			
	static public List<String> __latin = new ArrayList<String>();
	static public List<String> __eastern = new ArrayList<String>();
	static public List<String> __muslim = new ArrayList<String>();
	static public List<String> __indian = new ArrayList<String>();
	static public List<String> __chinese = new ArrayList<String>();
	static public List<String> __african = new ArrayList<String>();
	static public List<String> __new_world = new ArrayList<String>();

	static private String     __destPath;

	public String                    _tag;
    public Country                   _main;
    public CvCountry                 _liege;
    private FieldSet<County>         _owned;
    private FieldSet<County>         _controlled;
    public TreeSet<CvRelationships>  _relationships;
    public String[]                  _cultures;
    public TreeSet<CvProvince>       _provinces;
    public CvProvince                _capital;
    public String                    _eu3Tag;
    public CharacterCvRules.Leader   _leader  = null; 
    public boolean                   _removed = false;
    public EU3Country                _country;

	
    static public TreeSet<CvCountry> __list    = new TreeSet<CvCountry>();
    static public TreeSet<CvCountry> __removed = new TreeSet<CvCountry>();
    
    static public TreeSet<EU3Country> __eu3List = new TreeSet<EU3Country>();
    
    /*
     * Finds a county controller.
     */
    static public CvCountry getCountyController(County p) {
    	CvCountry x = search(p._controller._tag);
    	if (x!=null && x._controlled.contains(p)) return x;
    	CvCountry y = search(p._controller._liege._tag);
    	if (y!=null && y._controlled.contains(p)) return y;
    	CvCountry z = search(p._controller._liege._liege._tag);
    	if (z!=null && z._controlled.contains(p)) return z;
    	checkFatal(null,"eu3 county controller",p._id);
    	return null;
    }
    
    /*
     * Finds a county owner.
     */
    static public CvCountry getCountyOwner(County p) {
    	CvCountry x = search(p._owner._tag);
    	if (x!=null && x._owned.contains(p)) return x;
    	CvCountry y = search(p._owner._liege._tag);
    	if (y!=null && y._owned.contains(p)) return y;
    	CvCountry z = search(p._owner._liege._liege._tag);
    	if (z!=null && z._owned.contains(p)) return z;
    	checkFatal(null,"eu3 county owner",p._id);
    	return null;
    }
    
    /*
     * remove countries with no county ; likely an country still existing
     * because it has roaming armies.
     */
    static public TreeSet<CvCountry> purgeEmpty() {
		for (CvCountry c : __list)
			if (c._controlled.isEmpty() && c._owned.isEmpty() && !c._tag.equals("REBE")) {
				System.out.format("removed %s due to lack of territory (no counties)\n",c._tag);
				__removed.add(c);
				c._removed = true;
			}
		__list.removeAll(__removed);
		return __removed;
    }
    
    /*
     * remove countries with no province (after province assignment).
     */
    static public TreeSet<CvCountry> purgeNoProvince() {
		for (CvCountry c : __list)
			if (c._provinces.isEmpty() && !c._tag.equals("REBE")) {
				System.out.format("removed %s because it did not qualify for any province\n",c._tag);
				__removed.add(c);
				c._removed = true;
		    }
		__list.removeAll(__removed);
		return __removed;
    }
    
    /*
     * Sanity check that all CK provinces are known
     */
    static private void sanityCheck() {
		int n=0;
		int m=0;
		for (CvCountry c : __list) {
			n+=c._controlled.size();
			m+=c._owned.size();
		}
		if (n!=County.__list.size()) {
		    System.out.format("%d counties found (control) : %d were expected\n", n, County.__list.size());
			for (CvCountry c : __list)
				County.__list.removeAll(c._controlled);
			System.out.println("counties not found are");
			for (County c : County.__list)
				System.out.println(c._id);
		    System.exit(0);
		}
		if (m!=County.__list.size()) {
		    System.out.format("%d counties found (ownership) : %d were expected\n", m, County.__list.size());
			for (CvCountry c : __list)
				County.__list.removeAll(c._owned);
			System.out.println("counties not found are");
			for (County c : County.__list)
				System.out.println(c._id);
		    System.exit(0);
		}
    }
    
    /*
     * Sanity check that all CK countries have correct vassalization links.
     * Still, we don't halt the program but remove the vassalization link
     */
    static private void CKsanityCheck() {
		for (Country x : Country.__list) {
			Title.Tier myTier=x._title._tier;
			if (x._holder._main._liege==null) continue;
			Title.Tier liegeTier=x._liege._title._tier;
			if (myTier==Title.Tier.KINGDOM && x._tag.equals("JERU") && liegeTier==Title.Tier.KINGDOM) continue;
			if (myTier==Title.Tier.DUCHY && liegeTier==Title.Tier.KINGDOM) continue;
			if (myTier==Title.Tier.COUNTY && liegeTier!=Title.Tier.COUNTY) continue;
		    System.out.println("("+x._tag+", rank "+myTier.toString()+") has liege ("+x._liege._tag+", rank "+liegeTier.toString()+") : ranks are not consistent");
		    // at this point, either make a kingdom vassal independent or move a duke vassal up a rank.
		    if (myTier==Title.Tier.KINGDOM) {
		    	x._holder._main._liege = null;
		    	x._liege = null;
			    System.out.println("("+x._tag+", rank "+myTier.toString()+") made independent");
		    } else {
		    	x._holder._main._liege = x._holder._main._liege._holder._main._liege;
		    	x._liege = x._liege._liege;
		    	if (x._holder._main._liege==null) {
				    System.out.println("("+x._tag+", rank "+myTier.toString()+") made independent");		    	 
		    	} else {
		    		System.out.println("("+x._tag+", rank "+myTier.toString()+") liege moved to ("+x._liege._tag+", rank "+liegeTier.toString()+")");
		    	}
		    }
		}
    }    
	
	static public void setOutputPath(String path) throws IOException {
		__destPath = path;
		File dir = new File(path);
		if (dir.exists()) {
//			for (File f: dir.listFiles())
//				f.delete();
		}
		else if (!dir.mkdirs())
			throw new IOException("Unable to create directory : "+dir);
	}
	
    static public void makeCountries() {
    	CKsanityCheck();
    	findIndependents();
    	findOthers(Title.Tier.KINGDOM);
    	findOthers(Title.Tier.DUCHY);
    	findOthers(Title.Tier.COUNTY);
    	sanityCheck();
    }
    
    static public void checkCapitals() {
		for (CvCountry c : __list) {
			if (c._capital!=null) continue;
			if (c._tag.equals("REBE")) continue;
			int n = Rnd.get().nextInt(c._provinces.size());
			CvProvince[] p = c._provinces.toArray(new CvProvince[c._provinces.size()]);
			p[n]._isCapital = true;
			c._capital = p[n];
		}
   	
    }

    static private void findIndependents() {
		for (Country x : Country.__list) {
			if (x._holder._main._liege==null) {
				CvCountry c = new CvCountry(x);
				System.out.println("created independent country : "+x._tag);
				__list.add(c);
			}
		}
    }
    
    static private void findOthers(Title.Tier tier) {
		//find semi-independent titles
		for (Country x : Country.__list) {
			if (x._title._tier!=tier || x._holder._main._liege==null) continue;
			CvCountry liege = search(x._liege._tag);
			boolean liegeMerged=false;
			if (liege==null && x._title._tier==Title.Tier.COUNTY) {
				//At this point, a kingdom would have been created, so liege would exist
				liege = search(x._liege._liege._tag);
				liegeMerged=true;
			}
			int r = MergeRules.checkCountryStatus(x,liegeMerged);
			if (r==CountryCvRules.MERGE) {  //MERGE
				System.out.println("merged : "+x._tag);
				liege._controlled.addAll(x._controlled);
				liege._owned.addAll(x._owned);
			}
			else {  //independent
				if (liegeMerged) {
					System.out.println("subvassal count declared independence : "+x._tag);
				} else {
					System.out.println("vassal gained independence : "+x._tag);
				}
				CvCountry c = new CvCountry(x);
				// add to the independent map in case we need to reclaim.
				__declaredIndependence.put(x, c);
				CvRelationships rel = CvRelationships.add(liege, c, r);
				if (rel!=null) {
				    c._relationships.add(rel);
				    liege._relationships.add(rel);
				}
		        c._liege=liege;
		        __list.add(c);
		    }
		}
	}
	
	
	public void print(PrintWriter out) {
		int n=0;
		for (CvProvince p : _provinces) {
			if (p._controller!=p._owner)
				n++;
		}
		if (n==0)
		    out.format("%s - %s (%d owned counties / %d controlled counties / %d provinces)", _tag,_eu3Tag,_owned.size(),_controlled.size(),_provinces.size());
		else
		    out.format("%s - %s (%d owned counties / %d controlled counties / %d provinces / %d contested provinces)", _tag,_eu3Tag,_owned.size(),_controlled.size(),_provinces.size(),n);
			if (_liege!=null) out.format(" (liege %s) ", _liege._tag);
		for (CvRelationships r: _relationships) {
			String other = (r._first._tag.equals(_tag)) ? ">"+r._second._tag : "<"+r._first._tag;
			if (r._first._removed || r._second._removed) continue;
            if (r._type==CvRelationships.Type.UNION)
			    out.format(" (union %s) ", other);
            else if (r._type==CvRelationships.Type.VASSAL)
			    out.format(" (vassal %s) ", other);
            else if (r._type==CvRelationships.Type.ALLIANCE)
			    out.format(" (ally %s) ", other);
            else if (r._type==CvRelationships.Type.MARRIAGE)
			    out.format(" (marry %s) ", other);
		}
		out.println();
	}
	
	static public void getAllTags() {
		TreeSet<CvCountry> list = new TreeSet<CvCountry>(__list);
		System.out.format("%d countries to convert, %d tags available\n", list.size(),TagCvRules.nbTags());
		//assign tags, beginning by the most important countries
		getAllTags(list,Title.Tier.KINGDOM);
		getAllTags(list,Title.Tier.DUCHY);
		getAllTags(list,Title.Tier.COUNTY);
		if (!list.isEmpty()) {
			//some countries not yet assigned ? try any method to grab a tag!
			TreeSet<CvCountry> done = new TreeSet<CvCountry>();
			for (CvCountry x : list) {
				x.getTag(4,done);
			}
			//check all countries have on tag assigned
			int extraCount = 0;
			if (done.size()!=list.size()) {
				extraCount = list.size() - done.size();
				list.removeAll(done);
				done = new TreeSet<CvCountry>();
				System.out.println("Need " + extraCount + " fewer countries...merging...");
				while ((extraCount > 0) && (__declaredIndependence.size() > 0)) {
					Country[] xes = new Country[__declaredIndependence.keySet().size()];
					__declaredIndependence.keySet().toArray(xes);
					Country x = xes[rng.nextInt(xes.length)];
					CvCountry c = __declaredIndependence.get(x);
					
					if (null != c._eu3Tag) {
						// remerge this sob...
						// step 1, add all to the liege...
						CvCountry liege = search(x._liege._tag);
						if (liege==null && x._title._tier==Title.Tier.COUNTY) {
							//At this point, a kingdom would have been created, so liege would exist
							if (null != x._liege._liege) {
								liege = search(x._liege._liege._tag);
							} else {
								// bad merge candidate for some reason.
								__declaredIndependence.remove(x);
								continue;
							}
						}
						System.out.println("merged (2d pass): " + x._tag + " (" + c._eu3Tag + ") with: " + liege._tag + " (" + liege._eu3Tag + ")");
						liege._controlled.addAll(x._controlled);
						liege._owned.addAll(x._owned);
						// step 2... undo the independence.
						__declaredIndependence.remove(x);
						NavigableSet<CvRelationships> subs = CvRelationships.remove(liege, c);
						c._relationships.removeAll(subs);
						liege._relationships.removeAll(subs);
						
						__list.remove(c);					
						TagCvRules.restoreTag(c._eu3Tag);
						
						// and, see if we can grab another tag now...
						for (CvCountry x2 : list) {
							x2.getTag(4, done);
							if (null != x2._eu3Tag) {
								extraCount--;
								list.remove(x2); // so we don't see this country again.
							}
							break; // really only want to handle one at a time here.
						}
					} else {
						// I assume it got de-independencized (presumably did not qualify for any province)
						__declaredIndependence.remove(x);
					}
				}
			}
			if (extraCount > 0) {
				// ok, if we haven't found one by now, we're toast.
				list.removeAll(done);
				for (CvCountry c : list)
					System.out.println(c._tag);
				throw new IllegalStateException("Could not convert all tags : "+list.size()+" still to finalize "+done.size()+" done");
			}
		}
		//now load EU3 data
		for (CvCountry c : __list)
			if (c._eu3Tag!=null && !c._eu3Tag.equals("REB"))
				try {
				    c._country = EU3Country.get(c._eu3Tag);
				}
				catch (Exception e) {
					System.out.println("unable to load EU3 country "+c._eu3Tag);
					e.printStackTrace();
					System.exit(0);
				}
	}
	
	static private void getAllTags(TreeSet<CvCountry> list, Title.Tier tier) {
		TreeSet<CvCountry> done = new TreeSet<CvCountry>();
		TreeSet<CvCountry> todo = new TreeSet<CvCountry>();
		//create list of countries for the appropraite tier
		for (CvCountry x : list)
			if (x._main._title._tier==tier)
				todo.add(x);
		//for each of them, get a tag by first beginning by the "best" method
		//i.e. tag translation, then degrading to fuzzier methods (tag from
		//owned territory)
		int lvl=0;
		do {
			for (CvCountry y : todo)
				y.getTag(lvl,done);
			todo.removeAll(done);
			list.removeAll(done);
			done.clear();
		}
		while (todo.size()!=0 && ++lvl<=3);
	}
	
	private void getTag(int limit, TreeSet<CvCountry> done) {
		if (_eu3Tag!=null) return;
		//at limit 2 or more, we are trying for any territory under that
		//nominal title ; better try first "preferred" tags from actually
		//owned provinces, starting with the capital
		if (limit==2) {
			String[] l = new String[_provinces.size()];
			int i=0;
			for (CvProvince p : _provinces) {
				if (p._data._prefered==null || p._data._prefered.length==0 || p._data._prefered[0]==null) continue;
				String c=null;
				if (p._isCapital) c=p._data._prefered[0];
				else l[i++] = p._data._prefered[0];
				if (c!=null) l[i++]=c;
			}
			if (i>0)
			    _eu3Tag = TagCvRules.getTag(l);
		}
		if (_eu3Tag==null)
	        _eu3Tag = TagCvRules.getTag(_main, limit);
	    if (_eu3Tag!=null)
		    done.add(this);
	}

	private void preWrite() throws IOException {	
		if (_tag.equals("REBE")) return;
		_country.setSlider(EU3Country.Slider.ARISTOCRACY, CountryCvRules.SliderRule.__aristocracy_plutocracy.getValue(_owned, _main));
		_country.setSlider(EU3Country.Slider.CENTRALIZATION, CountryCvRules.SliderRule.__centralization_decentralization.getValue(_owned, _main));
		_country.setSlider(EU3Country.Slider.INNOVATIVENESS, CountryCvRules.SliderRule.__innovative_narrowminded.getValue(_owned, _main));
		_country.setSlider(EU3Country.Slider.LAND, CountryCvRules.SliderRule.__land_naval.getValue(_owned, _main));
		_country.setSlider(EU3Country.Slider.MERCANTILISM, CountryCvRules.SliderRule.__mercantilism_freetrade.getValue(_owned, _main));
		_country.setSlider(EU3Country.Slider.OFFENSIVE, CountryCvRules.SliderRule.__offensive_defensive.getValue(_owned, _main));
		_country.setSlider(EU3Country.Slider.QUALITY, CountryCvRules.SliderRule.__quality_quantity.getValue(_owned, _main));
		_country.setSlider(EU3Country.Slider.SERFDOM, CountryCvRules.SliderRule.__serfdom_freesubjects.getValue(_owned, _main));
	    _country.setCapital(_capital._id);
	    _country.setMonarch(CharacterCvRules.getMonarch(_main._holder));
	    _country.setReligion(CountryCvRules.getReligion(_main._holder,_capital._province._religion));
		CultureCvRules.EU3Culture[] cultures = cultures();
		_country.setCulture(cultures[0]._culture);
		for (int i=1; i<cultures.length; i++)
		    _country.addCulture(cultures[i]._culture);
		
		String tech = CountryCvRules.TechGroupRule.getTechGroup(_country._religion, cultures[0]);
		_country.setTechGroup(tech);
		String ckForm = _main._base.getBase("form_of_goverment").get();
		_country.setGovType(CountryCvRules.GovernmentRule.getGovType(_country._religion, cultures[0], ckForm, _main._laws));
		if (_leader!=null) {
		    _country.addLeader("general", _leader._birth, _leader._month, _leader._day, _leader._death, (byte)1, _leader._name, (byte)_leader._fire, (byte)_leader._shock, (byte)_leader._manuever, (byte)_leader._siege);
		}
		_country.setStability(_main._stability);
		_country.setBadboy(_main._badboy);
		_country.setTreasury((double) _main._holder._gold);
	}
	
	private CultureCvRules.EU3Culture[] cultures() {
		//first, check the leadership cultures : it determines the most important cultures
		float limit= (float)0.15;
		CultureCvRules.EU3Culture[] res = new CultureCvRules.EU3Culture[50];
		int n=0;
		
		//leadership culture
		CultureCvRules.CultureCounter cnt0 = new CultureCvRules.CultureCounter();
		for (County c : _owned)
			cnt0.add(CultureCvRules.__list.search(c._owner._holder._culture)._EU3culture, (float)1.0);
		CultureCvRules.EU3Culture[] leaderCultures = cnt0.getCulture(limit);
		System.arraycopy(leaderCultures, 0, res, 0, leaderCultures.length);
		n=leaderCultures.length;

		//major culture in major culture group
		CultureCvRules.CultureCounter cnt1 = new CultureCvRules.CultureCounter();
		for (CvProvince p : _provinces)
			cnt1.add(p._culture, p._province._citysize);
		CultureCvRules.EU3Culture culture = cnt1.getCulture();
		boolean found = false;
		for (int i=0; i<n && !found; i++) 
			found = res[i]._culture.equals(culture._culture);
		if (!found) res[n++]=culture;
		
		//king culture
		CultureCvRules c = CultureCvRules.__list.search(_main._holder._culture);
		checkFatal(c,"culture",_main._holder._culture+" in cvdata.txt");
		culture = c._EU3culture;
		found = false;
		for (int i=0; i<n && !found; i++) 
			found = res[i]._culture.equals(culture._culture);
		if (!found) res[n++]=culture;
		
		//capital culture
		culture = _capital._culture;
		found = false;
		for (int i=0; i<n && !found; i++) 
			found = res[i]._culture.equals(culture._culture);
		if (!found) res[n++]=culture;
		
		CultureCvRules.EU3Culture[] result = new CultureCvRules.EU3Culture[n];
		System.arraycopy(res, 0, result, 0, n);
		return result;
	}

	static public void preWriteAll() throws IOException {
		for (CvCountry c : __list) {
			if (c._eu3Tag!=null) {
			    c.preWrite();
			    // sanity check for rebels
			    if (null != c._country) {
			    	__eu3List.add(c._country);
			    }
			}
		}
	
		// now pick up the baseline tags for the remainder of the tag pool and then the ROTW.  some of these are later-arising countries,
		// and so not necessarily in existence at start time...
		// apparently, though, the tags and full descriptions stay in the list,
		// so keep it up.
		for (String tag: TagCvRules.getListTags()) {
			EU3Country eu3c = EU3Country.get(tag);
			eu3c.takeEU3Defaults();
		    __eu3List.add(eu3c);
		}
		for (String tag: __rotw_tags) {
			// see if we already have this country.  a few countries can be used or left as rotw.
			if (!TagCvRules.isUsed(tag)) {
				EU3Country eu3c = EU3Country.get(tag);
				eu3c.takeEU3Defaults();
			    __eu3List.add(eu3c);
			} else {
				System.out.println("Used possible ROTW country: " + tag);
			}
		}
	}
	
	static public void calcRelations() {
		for (EU3Country eu3c : __eu3List) {
			/*
			if ("ARA".equals(eu3c._tag)) {
				System.out.println("ARA");
			}
			*/
			// does this country hold any territory?
			if (eu3c.hasProvinces()) {
				// calc for every other country...but since the relations are symmetric, it should be 
				// no trouble.
				for (EU3Country c2 : __eu3List) {
					// don't bother recalculating if we already have, or if the other
					// country has no territory either.
					if ((null == eu3c.getRelationTo(c2._tag)) && c2.hasProvinces()) {																	
						int rel = 0;
						
						// see if we have even discovered these guys.  Otherwise we keep the 0.
						if (eu3c.hasDiscovered(c2)) {						
							// ok, if this is us, the relation is a flat 110 to start
							if (eu3c._tag.equals(c2._tag)) {
								rel = 110;
							} else {
								// baseline is determined by religion.  For Christian groups, 
								// same religion gets +35, cross-christian gets -65, 
								// cross-religion gets -115, before any modifiers.
								// for non-christians, same gets +85.
								if (eu3c.isSameReligionAs(c2)) {
									if (eu3c.isChristian()) {
										rel = 35;
									} else {
										rel = 85;
									}
								} else {
									if (eu3c.isSameReligiousGroupAs(c2)) {
										rel = -65;
									} else {
										rel = -115;
									}
								}
								
								// -10 for monarch / republic crosses
								if ((eu3c._gov_type.contains("monarchy") && 
										c2._gov_type.contains("republic")) ||
									(eu3c._gov_type.contains("republic") && 
										c2._gov_type.contains("monarchy"))) {
									rel -= 10;
								}
																
								// +50 for royal marriage
								if (eu3c.isRMWith(c2)) {
									rel += 50;
								}
								
								// +100 for alliance
								if (eu3c.isAllianceWith(c2)) {
									rel += 100;
								}

								// +150 for vassal
								if (eu3c.isVassalWith(c2)) {
									rel += 150;
								}

								// +200 for union								
								if (eu3c.isUnionWith(c2)) {
									rel += 200;
								}
								
								// -200 for war
								if (eu3c.isWarWith(c2)) {
									rel -= 200;
								}
							}
						}
						
						// clamp to the -200<-->200 range.
						rel = Math.max(-200, rel);
						rel = Math.min(200, rel);
						eu3c.setRelationTo(c2._tag, rel);
					}
				}
			}
		}
	}
	
	static public void writeAll() throws IOException {
		for (EU3Country eu3c : __eu3List) {
			eu3c.write(__destPath + File.separatorChar + Analyzer.getSaveFile());
		}
	}
	
	static public void calcTechGroups() {
		for (CvCountry c : __list) {
			if ((c._eu3Tag != null) && (c._country != null)) {
				String tech = CountryCvRules.TechGroupRule.getTechGroup(c._country._religion, c.cultures()[0]);
				if ("latin".equals(tech)) {
					__latin.add(c._eu3Tag);
				} else if ("eastern".equals(tech)) {
					__eastern.add(c._eu3Tag);
				} else if ("muslim".equals(tech)) {
					__muslim.add(c._eu3Tag);
				} else if ("indian".equals(tech)) {
					__indian.add(c._eu3Tag);
				} else if ("chinese".equals(tech)) {
					__chinese.add(c._eu3Tag);
				} else if ("african".equals(tech)) {
					__african.add(c._eu3Tag);
				} else if ("new_world".equals(tech)) {
					__new_world.add(c._eu3Tag);
				} else {
					System.out.println("WTF: invalid tech type: " + tech + " for: " + c._eu3Tag);
				}				
			}
		}
	}
	
    CvCountry(String tag) {
    	_tag = tag;
    }
    private CvCountry(Country x) {
    	_tag  = x._tag;
    	_main = x;
    	_owned         = new FieldSet<County>(County.class);
    	_controlled    = new FieldSet<County>(County.class);
    	_relationships = new TreeSet<CvRelationships>();
    	_provinces     = new TreeSet<CvProvince>();
    	_cultures      = MergeRules.getCultures(x);
    	_controlled.addAll(x._controlled);
    	_owned.addAll(x._owned);
   }

	static public CvCountry search(String tag) {
		CvCountry dummy0 = new CvCountry(tag);
		CvCountry dummy1 = new CvCountry(tag+"\0");
		SortedSet<CvCountry> sub = __list.subSet(dummy0,dummy1);
		if (sub.isEmpty()) return null;
		return sub.first();
	}
	static public boolean isRemoved(String tag) {
		CvCountry dummy0 = new CvCountry(tag);
		CvCountry dummy1 = new CvCountry(tag+"\0");
		SortedSet<CvCountry> sub = __removed.subSet(dummy0,dummy1);
		return !sub.isEmpty();
	}

    public int compareTo(CvCountry c) { return _tag.compareTo(c._tag); }

}
